{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location": "/archive/", "text": "news archive", "title": "Articles"},{"location": "/feed.xml", "text": "chicory ai chicory ai documentation http localhost 4000 chicory github io thu 09 jan 2025 04 47 14 0800 thu 09 jan 2025 04 47 14 0800 jekyll v3 10 0", "title": ""},{"location": "/forum/", "text": "discussion forumwhat questions are being asked on https ask cyberinfrastructure org the questions below are from the stanford research computing category", "title": "Discussion Forum"},{"location": "/", "text": "welcome to chicory aithis is a documentation page for chicory ai discovery offering for features getting started with development see the getting started page would you like to request a feature or contribute open an issuehere are the assets from the above instructions", "title": "Chicory AI - Discovery"},{"location": "/search/search_index.json", "text": "config lang en prebuild index false separator s docs for page in site pages unless page excluded in search if added endif assign added false location page url text page content strip html strip newlines slugify ascii replace title page title assign added true endunless endfor for post in site posts unless page excluded in search if added endif assign added false location post url text post content strip html strip newlines slugify ascii replace title post title assign added true endunless endfor for doc in site docs unless doc excluded in search if added endif assign added false location doc url text doc content strip html strip newlines slugify ascii replace title doc title assign added true endunless endfor", "title": ""},{"location": "/sitemap.xml", "text": "now date y m d daily for section in site data toc site baseurl section url now date y m d daily endfor", "title": ""},{"location": "/assets/css/style.css", "text": "import jekyll theme primer", "title": ""},{"location": "/docs/deployment", "text": "setup instructionsthis guide provides detailed instructions to set up aws resources using terraform deploy a dummy service on kubernetes using a helm chart and manage the deployment with argo cd versioning terraform configuration version v1 9 8 helm chart version v3 16 3 compatible kubernetes version v1 31 refer to the changelog for details about updates and changes in each version prerequisitesbefore starting ensure the following tools are installed terraform installation guide kubectl installation guide helm installation guideaccessing aws ecr docker image to be done by chicory team 1 validation of ecr policy json updating chicory s ecr permission with user prod account details version 2012 10 17 statement effect allow principal aws arn aws iam lt user prod account id gt role lt role name gt action ecr batchchecklayeravailability ecr batchgetimage ecr getdownloadurlforlayer 2 ecr repository details chicory will share ecr repo details lt chicory prod id gt dkr ecr us west 2 amazonaws com chicory discovery inference latest lt chicory prod id gt dkr ecr us west 2 amazonaws com chicory discovery training latestmanual pre requisite stepsthese steps must be completed before running terraform 1 aws environment setup ensure you have an aws account with sufficient permissions to manage eks vpc subnets route tables and certificates configure the aws cli for authentication aws configure profile lt profile name gt 2 optional obtain an ssl certificate optional for https use aws certificate manager to request a certificate for your domain aws acm request certificate domain name lt your domain gt validate the certificate using dns or email verification 3 optional create a route 53 hosted zone if using a custom domain name set up a hosted zone in route 53 and link it to the vpc 4 enable kubernetes access install kubectl and eksctl brew install kubectl eksctl if not using terraform for eks create a cluster manually eksctl create cluster name lt cluster name gt region us west 2 nodegroup name lt cluster name gt node group steps to execute1 update kubectl context and create chicory nsaws eks region lt region gt update kubeconfig name lt cluster name gt kubectl create namespace chicory ai2 create s3 bucket if not using the terraformaws s3 mb chicory agent api bucket region lt region gt make sure to provide access to eks cluster for training job to persist data either using service role refer https docs aws amazon com eks latest userguide using service linked roles html or pass env to training job aws access key id aws access id for s3 access in case iam amp service role is not setup aws secret access key aws secret key for s3 access in case iam amp service role is not setup you can leverage shared terraform script for the same 1 edit variables update the terraform prod tfvars file with required values region target region app name app name default chicory agent api eks cluster name cluster name 2 initialize and apply terraform navigate to the s3 terraform directory terraform initterraform validateterraform plan var file prod tfvarsterraform apply var file prod tfvars confirm the changes to provision the infrastructure debugging steps verify the service account for ebs csi check the service account used by the ebs csi controller kubectl get sa ebs csi controller sa n kube system o yaml create an iam role for ebs csi driver aws iam create role role name ebscsidriverrole assume role policy document version 2012 10 17 statement effect allow principal service eks amazonaws com action sts assumerole attach the amazonebscsidriverpolicy aws iam attach role policy policy arn arn aws iam aws policy service role amazonebscsidriverpolicy role name ebscsidriverrole annotate the service account annotate the ebs csi controller service account to use the newly created iam role kubectl annotate sa ebs csi controller sa n kube system eks amazonaws com role arn arn aws iam lt account id gt role ebscsidriverrole 3 deploy chicory resources with helm1 deploy the helm chart required secrets envs openai api key databricks access token databricks host databricks http path databricks catalog databricks schema slack bot id slack signing secret slack bot token project s3 bucket example snippet for values yaml secrets openai api key lt your api key gt api key for openai integration databricks access token lt your databricks token gt api token for databricks databricks host lt your databricks host gt url of your databricks workspace databricks http path lt your http path gt http path for your databricks cluster or sql endpoint databricks catalog lt your databricks catalog gt databricks catalog name databricks schema lt your databricks schema gt databricks schema name slack bot id lt your slack bot id gt unique id of the slack bot slack signing secret lt your slack signing secret gt signing secret for validating slack requests slack bot token lt your slack bot token gt api token for the slack bot cd helm helm install chicory app n chicory ai f values yaml 3 verify deployment checking services on kubernetes kubectl get all n chicory ai access slack endpoint https external ip kubectl get svc discovery api n chicory ai access cron job logs kubectl get pods n chicory ai grep training job sync first find the job podkubectl logs lt pod name gt n chicory ai then get the logs using the pod name 5 required restart your discovery svc after job training completeskubectl rollout restart deployment discovery api n chicory aisummarythis guide ensures that the necessary aws resources and kubernetes infrastructure are in place the dummy service is deployed and external integrations are supported for further assistance refer to the documentation folder or contact the support team appendixsteps to execute for creating your own eks cluster1 edit variables update the terraform prod tfvars file with required values region target region app name app name default chicory agent api desired node count desired kubernetes node count node group instance type cluster node group instance requires memory max node count maximum node count min node count minimum node count cert optional arn for ssl certificate if using https 2 initialize and apply terraform navigate to the terraform directory terraform initterraform validateterraform plan var file prod tfvarsterraform apply var file prod tfvars confirm the changes to provision the infrastructure 3 ensure ebs csi driver is installedafter configuring the current kube contexthelm repo add aws ebs csi driver https kubernetes sigs github io aws ebs csi driverhelm repo updatehelm install aws ebs csi driver aws ebs csi driver aws ebs csi driver namespace kube system set enablevolumescheduling true set enablevolumeresizing true set enablevolumesnapshot true verifykubectl get pod n kube system l app kubernetes io name aws ebs csi driver app kubernetes io instance aws ebs csi driver", "title": "Deployment"},{"location": "/docs/example-page", "text": "a nested pagethis is an example of a page that doesn t have a permalink defined andis not included in the table of contents data toc yml this meansthat it will render based on it s path since it s in docs example page md the url will be docs example page link to a subfoldernow let s say we want to link to a subfolder specifically with thissetup docs example page md we are here subfolder example page md we want to link hereyou can provide the relative path to the file like subfolder example page mdand jekyll will handle parsing it for example here is that linkand here is the same link but generated with the include statement include doc html name here path subfolder example page", "title": "A Nested Page"},{"location": "/docs/extras/example-quiz", "text": "quizzesas of version 0 0 12 mkdocs jekyll has support for basic quizzes these areintended to help educate your users about the content of your documentation for a quiz you can add a new file to the folder data quizzes and write a questions file based on the format shown in data quizzes example quiz yml here is a simple example of a multiple choice question which can also serve as true false title this is the quiz titlerandomized falsequestions type multiple choice question true or false pittsburgh is west of philadelphia items choice true correct true choice false correct false followup the answer is true pittsburgh is 304 9 miles west of philadelphia or approximately a car ride of 4 hours and 52 minutes buckle up the quiz is rendered with a show answer button below each question and whenthe user clicks it any questions that are flagged with correct true will be bolded and if a followup section is included it will be displayed see the live example at the end of this page optionstitleif you include a title it will be rendered at the top of the quiz this isoptional you can leave it out and add it before the include on the page randomif you want your questions to be presented randomly just add randomized trueto the data example quizif i want to include the quiz located at data quizzes example quiz yml i can do so like this include quiz html file example quiz the rendered quiz is shown here", "title": "Quiz"},{"location": "/docs/extras/index", "text": "extrasextras include other integrations that aren t relevant to style or customization but can further enhance your documentation pages currently we have supportfor adding interactive quizzes quizzes interactive code blockswould you like to see another question type or another kind of extra please open an issue https github com chicoryai chicory github io issues new", "title": "Extras"},{"location": "/docs/extras/interactive", "text": "interactive code blocksthanks to codefence you can easilyembed interactive code snippets in your documentation note that we have addedthe style and javascript file in this template that way we don t add extra code or styles to pages that don t need it examplesthese are from the main codefence page the goal is to show all the languages supported heck i bet there are a lot of new languages here c include lt stdio h gt int main printf hello dinosaur from c return 0 lt code fence lang c heading hello dinosaur from c gt lt textarea vue slot code gt include amp lt stdio h amp gt int main printf hello dinosaur from c return 0 lt textarea gt lt code fence gt c include lt iostream gt int main std cout lt lt hello dinosaur from c return 0 lt code fence lang cpp heading hello dinosaur from c gt lt textarea vue slot code gt include amp lt iostream amp gt int main std cout amp lt amp lt hello dinosaur from c return 0 lt textarea gt lt code fence gt c console writeline hello dinosaur from c lt code fence lang cs heading hello dinosaur from c gt lt textarea vue slot code gt console writeline hello dinosaur from c lt textarea gt lt code fence gt clojure ns main defn main println hello dinosaur from clojure lt code fence lang clojure heading hello dinosaur from clojure gt lt textarea vue slot code gt ns main defn main println hello dinosaur from clojure lt textarea gt lt code fence gt elixirio puts hello dinosaur from elixir lt code fence lang elixir heading hello dinosaur from elixir gt lt textarea vue slot code gt io puts hello dinosaur from elixir lt textarea gt lt code fence gt crystalputs hello dinosaur from crystal lt code fence lang crystal heading hello dinosaur from crystal gt lt textarea vue slot code gt puts hello dinosaur from crystal lt textarea gt lt code fence gt erlang module main export start 0 start gt io fwrite hello dinosaur from erlang lt code fence lang erlang heading hello dinosaur from erlang gt lt textarea vue slot code gt module main export start 0 start gt io fwrite hello dinosaur from erlang lt textarea gt lt code fence gt asm global start text start write 1 message 26 mov 1 rax system call 1 is write mov 1 rdi file handle 1 is stdout mov message rsi address of string to output mov 26 rdx number of bytes syscall invoke operating system to do the write exit 0 mov 60 rax system call 60 is exit xor rdi rdi we want return code 0 syscall invoke operating system to exitmessage ascii hello dinosaur from assembly n lt code fence lang asm heading hello dinosaur from gnu assembly gt lt textarea vue slot code gt global start text start write 1 message 26 mov 1 rax system call 1 is write mov 1 rdi file handle 1 is stdout mov message rsi address of string to output mov 26 rdx number of bytes syscall invoke operating system to do the write exit 0 mov 60 rax system call 60 is exit xor rdi rdi we want return code 0 syscall invoke operating system to exitmessage ascii hello dinosaur from assembly n lt textarea gt lt code fence gt gopackage mainimport fmt func main fmt println hello dinosaur from go lt code fence lang go heading hello dinosaur from go gt lt textarea vue slot code gt package mainimport fmt func main fmt println hello dinosaur from go lt textarea gt lt code fence gt haskellmain putstrln hello dinosaur from haskell lt code fence lang haskell heading hello dinosaur from haskell gt lt textarea vue slot code gt main putstrln hello dinosaur from haskell lt textarea gt lt code fence gt javaclass main public static void main string args system out println hello dinosaur from java lt code fence lang java heading hello dinosaur from java gt lt textarea vue slot code gt class main public static void main string args system out println hello dinosaur from java lt textarea gt lt code fence gt kotlinfun main println hello dinosaur from kotlin lt code fence lang kotlin heading hello dinosaur from kotlin gt lt textarea vue slot code gt fun main println hello dinosaur from kotlin lt textarea gt lt code fence gt luaprint hello dinosaur from lua lt code fence lang lua heading hello dinosaur from lua gt lt textarea vue slot code gt print hello dinosaur from lua lt textarea gt lt code fence gt nodeconsole log hello dinosaur from javascript lt code fence lang node heading hello dinosaur from javascript gt lt textarea vue slot code gt console log hello dinosaur from javascript lt textarea gt lt code fence gt php lt php echo hello dinosaur from php lt code fence lang php heading hello dinosaur from php gt lt textarea vue slot code gt amp lt php echo hello dinosaur from php lt textarea gt lt code fence gt pythonprint hello dinosaur from python lt code fence lang python heading hello dinosaur from python gt lt textarea vue slot code gt print hello dinosaur from python lt textarea gt lt code fence gt rprint hello dinosaur from r lt code fence lang r heading hello dinosaur from r gt lt textarea vue slot code gt print hello dinosaur from r lt textarea gt lt code fence gt rubyputs hello dinosaur from ruby lt code fence lang ruby heading hello dinosaur from ruby gt lt textarea vue slot code gt puts hello dinosaur from ruby lt textarea gt lt code fence gt rustfn main println hello dinosaur from rust lt code fence lang rust heading hello dinosaur from rust gt lt textarea vue slot code gt fn main println hello dinosaur from rust lt textarea gt lt code fence gt scalaobject main def main args array string println hello dinosaur from scala lt code fence lang scala heading hello dinosaur from scala gt lt textarea vue slot code gt object main def main args array string println hello dinosaur from scala lt textarea gt lt code fence gt swiftprint hello dinosaur from swift lt code fence lang swift heading hello dinosaur from swift gt lt textarea vue slot code gt print hello dinosaur from swift lt textarea gt lt code fence gt typescriptconsole log hello dinosaur from typescript lt code fence lang ts heading hello dinosaur from typescript gt lt textarea vue slot code gt console log hello dinosaur from typescript lt textarea gt lt code fence gt dimport std stdio void main writeln hello dinosaur from d lt code fence lang d heading hello dinosaur from d gt lt textarea vue slot code gt import std stdio void main writeln hello dinosaur from d lt textarea gt lt code fence gt perlprint hello dinosaur from perl lt code fence lang perl heading hello dinosaur from perl gt lt textarea vue slot code gt print hello dinosaur from perl lt textarea gt lt code fence gt rakusay hello dinosaur from raku lt code fence lang raku heading hello dinosaur from raku gt lt textarea vue slot code gt say hello dinosaur from raku lt textarea gt lt code fence gt zigconst std import std pub fn main void const stdout std io getstdout outstream try stdout print hello dinosaur from zig n lt code fence lang zig heading hello dinosaur from zig gt lt textarea vue slot code gt const std import std pub fn main void const stdout std io getstdout outstream try stdout print hello dinosaur from zig n lt textarea gt lt code fence gt dartvoid main print hello dinosaur from dart lt code fence lang dart heading hello dinosaur from dart gt lt textarea vue slot code gt void main print hello dinosaur from dart lt textarea gt lt code fence gt forth hello dinosaur from forth crbye lt code fence lang forth heading hello dinosaur from forth gt lt textarea vue slot code gt hello dinosaur from forth crbye lt textarea gt lt code fence gt adawith text io use text io procedure main is begin put line hello dinosaur from ada end main lt code fence lang ada heading hello dinosaur from ada gt lt textarea vue slot code gt with text io use text io procedure main is begin put line hello dinosaur from ada end main lt textarea gt lt code fence gt", "title": "Interactive Code Blocks"},{"location": "/docs/getting-started", "text": "getting startedthis guide provides detailed steps for integrating your infrastructure with various platforms including databricks github confluence and slack the goal is to ensure the services can perform api requests for reading data accessing repositories exporting documents and interacting with users 1 aws infrastructure setup terraform we will provide terraform scripts to deploy the necessary infrastructure required services eks elastic kubernetes service for managing containerized applications s3 simple storage service for storing data and logs api gateway to manage apis for service communication vpc virtual private cloud for secure network isolation 2 service overviewtraining service responsible for user onboarding and integration continuously indexes and manages the knowledge graph to ensure the system has up to date data relationships and insights inference service an agentic service designed for extracting the correct context from data and performing actions based on user interactions or automated triggers 3 openai api access agent access requirements access frequency and data rate can be customized based on the user s preferences and data handling needs use openai api key to enable api interactions 4 platform integration stepslist of supported platformssummaryfollowing the above steps will enable your infrastructure and services to integrate seamlessly with databricks github confluence and slack allowing for data access document management and user interactions", "title": "Getting Started"},{"location": "/docs/integration", "text": "integration guide for platform services1 databricks integrationgoal enable api access to run get requests and query data for reading current support scope single catalog single schemarequirements databricks workspace with api integration enabled api token for authentication values yaml file to pass necessary configurations as secret environment variables can be found in the helm chart directory steps generate api token log in to your databricks workspace go to user settings gt access tokens create a new token and save it securely take care since you won t be able to see this again update values add the following values in the values yaml file or pass them as environment variables for databricks integration databricks access token the api token generated in step 1 databricks host url of your databricks workspace e g https cloud databricks com databricks http path http path for your databricks cluster or sql endpoint this is found under the cluster or sql endpoint details in databricks e databricks catalog the catalog name in your databricks environment under which the data resides databricks schema the schema within the catalog where your target tables or data structures are located 2 google docsgoal enable api access to run get on google docs requirements google cloud account access with google doc api integration enabled credentials for authentication download credentials json file to pass necessary configurations as environment variables can be download from google cloud console steps set up google cloud project visit the google cloud console create a new project or select an existing one enable the google drive api navigate to apis amp services gt library search for google drive api and enable it set up a service account go to google cloud console navigate to google cloud console create a service account go to iam amp admin gt service accounts click create service account provide a name and description for the account assign permissions assign the editor or owner role to the service account or a custom role that allows accessing google drive files generate a key after creating the service account select it from the list click add key gt create new key and choose json download the json key file contains credentials like client email private key etc you will need to extract information from this file into deployment secrets share the google drive folder with the service account open google drive and locate the folder you want to access share the folder with the service account s email lt service account name gt lt project id gt iam gserviceaccount com and give it appropriate permissions e g viewer editor update values yaml file with environment variables for google docs integration google service account private key id extract from client secret json file google service account private key extract from client secret json file google service account client id extract from client secret json file google service account client email extract from client secret json file google service account client cert url extract from client secret json file google project id google cloud project id with enabled google doc api access google folder google folder id copy the folder s id from the url https drive google com drive folders 3 confluencegoal access and download documents html from confluence account current support scope supports confluence cloud and confluence server data center uses the confluence rest api for programmatic access to access single space outputs html files for all pages in the specified space requirements a confluence account with access to api token generation a confluence target space steps base url the url of your confluence instance example for confluence cloud https your domain atlassian net wiki example for confluence server data center https confluence your company com api token for confluence cloud generate via atlassian account s api token page https id atlassian com manage api tokens for server data center use username password or request an api token if supported space key the unique identifier for the confluence space found in the url e g spaces spacekey overview update values yaml file witk slack environment variables for confluence space integration confluence base url base url of confluence domain eg https chicory atlassian net wiki confluence api token api token with appropriate access confluence space key space id confluence email user email who owns the token 4 github integrationgoal enable api access to fetch repository data read files and integrate with an ai bot for automated analysis current support scope supports repository level access for reading files automates cloning reading and updating repository files provides integration with an ai agent for processing code or documentation requirements a github account with access to the repositories you wish to integrate a personal access token pat or organization level token with the required scopes a yaml configuration file for passing environment variables securely steps generate a personal access token pat log in to your github account go to settings gt developer settings gt personal access tokens gt tokens classic generate a new token with the following scopes repo full control of private repositories read org read only access to organization data if accessing organizational repositories workflow access workflows for triggering or managing github actions optional save the token securely as it will not be visible again update values add the following values in the values yaml file or pass them as environment variables for databricks integration github username your github username github access token the personal access token generated in step 1 github base url the base url for your github instance e g https api github com for github cloud or https api v3 for enterprise github 5 slack integrationgoal set up an installable slack bot to fetch chat messages from channels and integrate with an ai bot for the inference service requirements a slack bot token with necessary permissions a slack workspace configured to allow bot installation steps create a slack app go to the slack api dashboard click create an app and choose from scratch provide an app name e g chicory bot and select your workspace click create app configure oauth amp permissions in the app settings navigate to oauth amp permissions add the following bot token scopes under scopes chat write to send messages in channels and dms channels history to read message history from public channels app mentions read to listen for mentions of the bot im history to read message history in direct messages optional channels read to access basic channel information save changes slack integration config bash in short the steps to verify permissions navigate to your slack app dashboard at slack api apps go to oauth amp permissions and review the scopes listed under bot token scopes ensure the following scopes are included chat writechannels historyapp mentions readim history optional channels read generate oauth tokens click install app to workspace review the permissions and authorize the app for your workspace save the generated bot user oauth token securely slackbot token slackbot signing secret slackbot bot id with the oauth access token you can request for bot id it should start with b e g b01abcdefg curl x post h authorization bearer xoxb your token https slack com api auth test update values yaml file witk slack environment variables for slack integration slack bot id the unique id of your slack bot generated when you create the bot in the slack app dashboard and is used to reference the bot in slack interactions slack signing secret the signing secret for validating slack requests to your backend and helps to ensures that requests are genuinely from slack slack bot token the api token for your slack bot used for authenticating api calls made on behalf of the bot e g sending messages or interacting with users set up event subscriptions navigate to event subscriptions in your slack app settings enable event subscriptions and set the request url to your backend endpoint e g https your backend service com slack events add the following events under subscribe to bot events app mention to trigger the bot when it is mentioned message im to listen for direct messages optional for private interactions configure and reinstall the app after configuring the event subscriptions and permissions reinstall the app if needed by navigating to install app gt reinstall to workspace test the bot mention the bot in a channel using your bot name to ensure it interacts with the backend inference service and responds send a direct message to test interactions if message im is configured error scenarios test how the bot behaves when it cannot reach the backend or when invalid commands are sent set up ai bot for inference ensure the bot can process and respond to user interactions implement a backend service to handle incoming events from slack process them and send responses back through slack s web api example to post a response curl x post h authorization bearer lt your bot token gt h content type application json data channel lt channel id gt text here is your processed response https slack com api chat postmessage slack webhooks details link note webhooks can be created in incoming webhooks under the slack app settings example payload for sending messages with webhooks text this is a test message channel general add the app bot to target channel add the app to a channel settings of a channel gt integrations gt add apps gt target app alt text assets img slack app png add the bot to the channel like an user by using chicory this setup allows the slack bot to interact with users fetch content from channels and pass user inputs to the backend inference service for processing and responses summaryfollowing the above steps will enable your infrastructure and services to integrate seamlessly with databricks github confluence and slack allowing for data access document management and user interactions", "title": "Integration"},{"location": "/docs/subfolder/example-page", "text": "a nested pagethis is an example of a page that doesn t have a permalink defined andis not included in the table of contents data toc yml", "title": "A Nested Page"}]}
